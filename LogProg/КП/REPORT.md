# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студентка: Патрикеева Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|      7.12    |     5         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения данного курсового проекта я получу следующие навыки и знания:
1. Познакомлюсь с таким расширением файла, как GEDCOM, которое связано с файлами GEDCOM Genealogy Format. Раньше я никогда не сталкивалась с файлами такого рода.
2. Разберусь в структуре устройства данных в файле формата GEDCOM, а так же научусь писать парсер, который преобразовывает данные в этом файле в набор утверждений на языке Prolog.
3. Разберусь, что из себя представляет программа на языке Prolog и научусь писать, как минимум, самые простешие программы. А как максимум научусь реализовывать естественно-языковой интерфейс на английском языке.
4. Лучше буду понимать область применения логических языков программирования. 
5. Смогу на деле оценить все плюсы и минусы логических языков программирования, а конкретно - языка Prolog. 
6. Смогу ощутить разницу между императивными и декларативными языками программирования.
7. Научусь писать поиск в глубину и в ширину на языке Prolog для нахождения растояний между двумя соседними объектами.
8. После написания реферата стану лучше разбираться в устройстве языков логического программирования, а так же познакомлюсь с  их историей.  

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `father(отец, потомок)` и `mother(мать, потомок)`.
 3. Реализовать предикат проверки/поиска золовки.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для получения родословного дерева в формате GEDCOM я воспользовалась предоставленным мне сервисом MyHeritage.com. Данный сервис имеет приятный и удобный интерфейс, мне было легко и приятно в нём работать. Заполнять данное родословное дерево мне помогали мои родители и другие близкие родственники. К сожанию, у меня было не так много времени, чтобы составить максимально возможное родословное дерево, поэтому я остановилась на количестве в 54 человека.

## Конвертация родословного дерева

Для конвертации родословного дерева в набор фактов на языке Prolog я использовала язык С++. На момент выполнения этого задания, из предлагаемых языков для написания парсера мне были знакомы еще Python и Prolog, но на втором я только-только начинала учиться писать программы. Я выбрала именно С++, потому что опыт написания программ на данном языке программирования у меня намного больше нежели на других, а так же если сравнивать Python и C++, то второй работает намного быстрее. Используя контейнет map из библиотеки STL у меня легко получилось написать конвертер, код которого занимает всего лишь 40 строк.  
Алгоритм состоял в том, чтобы просто проходится по тексту в файле, и при нахождении специальных тегов, таких как GIVN, FAMC, FAMS, SEX записывает в струкруту хранения данных информацию, которую эти теги, можно сказать, предоставляют. Потом по результатам найденных данных формировались факты на языке Prolog. Код конвертера достаточно примитивный, с ним можно ознакомиться в файле converter.cpp


## Предикат поиска родственника

Мне необходимо было реализовать поиск золовки, т.е. сестры мужа. Для этого был написан предикат `sister_in_law`. Данный предикат включает в себя еще два предиката, первый это предикат `husband`, который ищет мужа человека, а второй это предикат `sister`, который ищет сестру определенного человека.  
Так как набор фактов о родственниках у меня имеет представление вида `father(отец, потомок)` и `mother(мать, потомок)`, то муж в понимании такого набора данных это тот человек, у которого с женой общие дети. Но из-за такого не очень удобного представления данных мы никак не сможем найти мужа женщины, если у них нет детей. Сестра же для такого набора данных это женщина (жеского пола), которая имеет с мужем общих родителей. Получается, что сестру, мы тоже не всегда сможем найти, а только, если у неё есть дети, поскольку предикат `mother` определяет женский род, и если у неё есть родители.
Ниже представлен реализованный предикат, который находит золовку для введённого человека.
```prolog
check_female(P) :- mother(P,_),!.

husband(Wife, Husband) :- mother(Wife, Child), father(Husband,Child). 

sister(Person, Sister) :- father(Father, Person), father(Father, Sister),
                          not(member(Person,[Sister])), check_female(Sister).
sister(Person, Sister) :- not(father(_, Person)), mother(Mother, Person), mother(Mother, Sister),
                          not(member(Person,[Sister])), check_female(Sister).

sister_in_law(Person, Sister) :- husband(Person, Husband), setof(S,sister(Husband, S), L), 
                                 member(Sister,L).
```
Поскольку у мужа и жены может быть несколько детей,там может находится несколько раз один и тот же муж, а для него несколько раз выведится одна и та же сестра. Чтобы этого избежать я использую setof, который находит всезвозможных сестёр без повторений, и записывает их в список. С помощью предиката `member` они по очереди все выводятся.

Результаты запросов :
```prolog

?- sister_in_law('Maria Chugina',X).
X = 'Irina Kuptsova'.

?- sister_in_law('Irina Kuptsova',X).
false.

?- sister_in_law('Lyudmila Potapova',X).
X = 'Maria Trofimova'.

?- sister_in_law('Lyudmila Potapova','Maria Trofimova').
true.

?- sister_in_law('Maria Chugina','Lyudmila Potapova').
false.
```
Как мы можем видеть, ответ для второго запроса не нашёлся, хотя у мужа Ирины Купцовой есть сестра и это Елена Патрикеева, но так как у неё нет детей, предикат, к сожалению, не может её найти.

## Определение степени родства

Для определения степени родства двух родственников в дереве необходимо было реализовать поиск в том или ином виде. Я создала два предиката для определения степени родства, один использует поиск в глубину, а другой поиск в ширину.  
Для того, чтобы получить цепочку родства, я составила предикат `movе`, который определяет переход в графе состояний. Ниже преставлена лишь часть когда, которая описывает эти переходы. 
Для того, чтобы переход осуществился, у человека должна быть связь с кем-то из родственников, это определяется с помощью таких предикатов как `mother`,`father` и т.д.
```prolog
mam(mother).
dad(father).
grndpa(grandfather).
grndma(grandmother).

move(X,Y,S) :- mother(Y,X), mam(S).
move(X,Y,S) :- father(Y,X), dad(S).
move(X,Y,S) :- grandpa(X,Y), grndpa(S).
move(X,Y,S) :- grandma(X,Y), grndma(S).
```
Если написать стандартные алгоритмы поиска в глубину и в ширину, то в качестве пути они будут выдавать фамилии и имена людей, через которые был проложен этот путь. Для того, чтобы все таки получить цепочку родства я ввела некоторые измения в алгоритмы.  
Для алгоритма поиска в глубину я ввела дополнительный список, который хранит информацию о том, кем является найденный человек по отношению к предыдущему, т.е. цепочка родства создается одновременно с цепочкой фамилий и имён людей. 
```prolog
prolong2([X|T],[Y,X|T],[S1|T2],[S,S1|T2]):-
    move(X,Y,S),
    not(member(Y,[X|T])).
	
path([X|T],X,[X|T], [Y|T2], [Y|T2]).
path(L, Y, R, S1, RS) :- prolong2(L, T, S1, S), path(T,Y,R,S,RS).

dfs_search(X,Y,R,S):-  path([X], Y, R,[start],L), append(S,[Z],L).

relatives(S,X,Y) :- dfs_search(X,Y,_,S).
```
Однако вывод при работе такого поиска получается не очень удобным, цепочки родства выводятся не в порядке увеличения их длины.
Поэтому я решила использовать алгоритм поиска в ширину. Однако, мне не удалось придумать, как можно записывать отношения родства по мере формирования пути. Я сделала по-другому.
Вначале просто выполняется поиск в ширину и находит путь, состоящий из фамилий и имён людей. Этот путь в виде списка с помощью специального предиката `convert` мы преобразуем в нужный результат. Данный предикат ищет отношение родства между двумя соседними  людьми в этом списке и записывает его в другой, в результате мы получаем нужную нам цепочку родства. Однако, при реализации такого алгоритма, нам требуется дополнительно еще раз проходиться по всему списку, что занимает какое-то время. В этом плане алгоритм, в основе которого лежит поиск в глубину, работает быстрее. Ниже представлен код поиска цепочки родства в ширину.
```prolog
prolong([X|T],[Y,X|T]):-
    move(X,Y,_),
    not(member(Y,[X|T])).
	
bfs([[X|T]|_],X,[X|T]).

bfs([X|Q],Y,R):-
    findall(P,prolong(X,P),L),
    append(Q,L,QQ),!,
    bfs(QQ,Y,R).
	
bfs([_|Q],Y,R):-
    bfs(Q,Y,R).
	
bfs_search(X,Y,L):-
    bfs([[X]],Y,L1), reverse(L1,L).


relative(L,X,Y) :- bfs_search(X,Y,L1), convert(L1,L).
convert([_|[]],[]):-!.
convert([X,Y|T],R) :- move(X,Y,S), append(R1,[S], R), convert([Y|T],R1),!.
```
Результаты работы программы :
```prolog

?- relative(L,'Lydia Patrikeeva','Irina Kuptsova').
L = [mother] ;
L = [wife, father] ;
L = [daughter, grandfather] ;
L = [daughter, grandmother] ;
L = [wife, son, grandfather] ;
L = [daughter, wife, grandfather] ;
L = [sister, son, grandfather] ;
L = [wife, son, grandmother] 

?- relative(L,'Maria Chugina','Irina Kuptsova').
L = [sister_in_law] ;
L = [sister, husband] ;
L = [daughter, father, husband] ;
L = [daughter, wife, father, husband] 

% использование поиска в глубину 
?- relatives(L,'Maria Chugina','Irina Kuptsova').
L = [daughter, wife, father, husband] ;
L = [daughter, father, husband] ;
L = [daughter, wife, son, wife, grandfather, husband] ;
L = [daughter, son, wife, grandfather, husband] ;

```

## Естественно-языковый интерфейс
Необходимо было разработать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.
Для реализации данного интерфейса я использовала DCG-нотацию, которая чаще всего применяется как раз таки для построения распознавателей контекстно-свободных грамматик. Для того, чтобы можно было задавать вопросы, был разработан предикат `question`.  
Система понимает четыре вида вопроса:
1. Is кто-то чей-то родственник ?
2. Who is чей-то родственник ?
3. How many родственник does кто-то have ?
4. Who is кто-то for кто-то ?  

Однако вопрос нужно вводить в виде списка слов, это, конечно не очень удобно.  
Вопросы в свою очередь рассматриваются как предложения, состоящие из вопросительного слова, группы глагола, группы подлежащего и группы дополнения, а так же символа вопросительного знака в конце.
На каждый вопрос пользователь получает осмысленный ответ. Для того, чтобы было возможно использовать him/her с отсылкой на упомянутый на прошлом шаге объект я использовала встроенные предикаты `nb_setval` и `nb_getval`, которые помогают устанавливать значение глобальной переменной и получать его. Моя программа запоминает в качестве he/his последнего введенного человека мужского пола, а в качестве she/her последнего введенного человека женского пола.  
Основная идея сводится к тому, что проверяется синтаксическая корректность вопроса, и, если вопрос задан правильно, то программа, исходя из переданных ей данных, используя разработанные на прошлых стадиях предикаты, выводит ответ.  
Код для выполнения данной части задания получился довольной громоздкий, поскольку я пыталась описать синтаксис вопроса максимально обще, а не под какой-то определенный вопрос. Очень много места в коде занимает непосредственно сам вывод ответа. 
```prolog
question(L):-question(L,[]).
question --> to_be(N), subject_clause(S), object_clause(X,Y,N), question_mark, 
             {first_answer(S,X,Y)}, !, {setval_f(S,X), setval_m(S,X) }.
question --> question_word, to_be(N), subject_clause(P), object_clause(P2), question_mark,
             {second_answer(P,P2,0)}, !, {setval_f(P,P2), setval_m(P,P2)}.

question --> question_word, to_be(N), object_clause(X,Y,N), question_mark,
             {second_answer(0,X,Y)}, !, {setval_f(_,X)}.
question --> question_words, relation(R,pl), verb_clause(N), subject_clause(P), h(pl), 
             question_mark, {change_n(R,R1), third_answer(R1,P)}, !, {setval_f(_,P)}.

subject_clause(S) --> person(S).
subject_clause(V) --> pronoun(S1,nq), {change(S1,S3), getval(S3,V)}.
object_clause(S,S2,N) --> person(S), ["'s"], relation(S2,N).
object_clause(V,S,N)--> pronoun(S1,q), {getval(S1,V)}, relation(S,N) .
object_clause(V,S,N)--> pronoun(S1,nq), {change(S1,S3), getval(S3,V)}, relation(S,N).
object_clause(S)--> preposition, person(S).
object_clause(V)--> preposition, pronoun(S1,q), {getval(S1,V)}.

verb_clause(N) --> to_be(N).
verb_clause(N) --> qto_be(N).

question_word --> [who].
question_words --> [how],[many].
question_mark --> [?].
preposition --> [for].
pronoun(S,q) --> {member(S, [his,her])},[S].
pronoun(S,nq)--> {member(S, [he,she])},[S].
h(ss)-->[has].
h(pl)-->[have].
to_be(ss)-->[is].
to_be(ss)-->['Is'].


relation(S,ss) --> {member(S, [father, mother, wife, husband, sister,
                               brother, grandfather, grandmother, son,
			       daughter, sister_in_law])}, [S].
relation(S,pl) --> {member(S, [fathers, mothers, wifes, husbands, sisters, 
                               brothers, grandfathers, grandmothers, sons, 
			       daughters, sisters_in_law])},[S].

person(X) --> {setof(Y,is_person(Y),L), member(X,L)},[X].
```
Здесь приведены только некоторые фрагменты кода, которые, как мне кажется, являются ключевыми для понимания моей задумки.  
  
Результат работы :  
```prolog 
?- question([is,'Galina Yusova','Irina Kuptsova', "'s", mother,?]).
YES, Galina Yusova is Irina Kuptsova's mother.

?- question([is,'Galina Yusova',her, mother,?]).
YES, Galina Yusova is Irina Kuptsova's mother.

?- question([is,'Irina Kuptsova', 'Lydia Patrikeeva', "'s", mother,?]).
YES, Irina Kuptsova is Lydia Patrikeeva's mother.

?- question([who,is,'Irina Kuptsova', "'s", husband,?]).
Vyacheslav Patrikeev is Irina Kuptsova's husband.

?- question([is,'Irina Kuptsova', 'Vyacheslav Patrikeev', "'s", wife,?]).
YES, Irina Kuptsova is Vyacheslav Patrikeev's wife.
true.

?- question([is, she, his, wife,?]).
YES, Irina Kuptsova is Vyacheslav Patrikeev's wife.
true.
```



## Выводы

Данный курсовой проект помог мне лучше понять логическое программирование. Написание реферата способствовало моему ознакомлению с теоретической частью, я узнала про историю развития логических языков, какие они бывают, для чего чаще всего используются, какие идеи и методы используют. А практические задания курсового проекта помогли мне закрепить теоретические знания. В ходе выполнения, я научилась писать программы на таком языке логического программирования, как Prolog. Я смогла написать на нём алгоритм поиска в длину и в ширину, при этом изменив немного код так, чтобы он работал, как мне нужно. Удивительно, что код на Prolog, который состоит из пару строчек, может заменить целую программу на другом каком-нибудь императивном языке программирования. Код на таком языке всегда довольно прост и понятен, но при этом он может выполнять действительно сложные и полезные действия. Так же в курсовом проекте у меня была возможность применить свою программу на деле. Я не просто смогла запрограммировать поиск в ширину, а смогла определять с помощью него степень родства членов своей семьи. С помощью такой программы я могу легко искать в этом дереве кого-угодно, даже когда это дерево "разрастётся" до  нескольких тысяч человек. Но больше всего в процессе выполнения заданий курсового проекта мне понравилось реализовывать естественно-языковый интерфейс, благодаря ему я узнала о существовании DCG-нотации, которая по итогу оказалась мне полезна и удобна. Такой интерфейс делает общение человека с программой значительно приятнее. 
  
Это был мой первый опыт работы с логическими языками программирования и я надеюсь, что не последний. С такими языками приятно работать, потому что они ориентированы на человеческое мышление, а не на компьютер, как, например, императивные языки программирования. Думаю, что данный курсовой проект научил меня в какой-то степени мыслить пуступательно и логически, для выполнения его заданий надо было отойти от стереотипов императивного программирования, ведь был необходим другой стиль мышления.

