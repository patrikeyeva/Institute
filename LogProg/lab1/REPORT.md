# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студентка: Патрикеева Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     27.10    |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

  В императивных языках для работы с последовательностью объектов предусмотрены специальные типы данных: массивы, файлы с последовательным доступом. В Prolog структура для хранения последовательности объектов называется списком, который определяется рекурсивно по соответствующему правилу. Списки обладают рядом существенных отличий от массивов. В частности, элемент может быть очень быстро добавлен или удален из начала односвязного списка. Однако операция произвольного доступа (обращения к n-ному элементу) в списках выполняется гораздо дольше, чем в массивах, т.к. требует n операций перехода. Но главное отличие списка от принятых в императивных языках подходов к хранению данных в том, что в Prolog это рекурсивная структура данных.
  
  Списки в Prolog можно представить в виде дерева определённого вида. Можно также провести аналогию списков Пролога и динамических однонаправленных списковых структур языка Паскаль. От последних их выгодно отличает отсутствие необходимости работать с адресной частью списков.


## Задание 1.1: Предикат обработки списка

`counter(Elem, List, Number)` - предикат реализует подсчёт числа вхождений заданного элемента Elem в список List. Number - число вхождений заданного элемента.

Примеры использования:
```prolog
| ?- counter('a',['a','b','c','a'],Number).
Number = 2

| ?- counter('t',['a','b','c','a'],Number).
Number = 0
```

Реализация без использования стандартных предикатов:
```prolog
counter(_,[],0):-!.
counter(E,[E|T],N):-counter(E,T,N1), N is N1+1,!. 
counter(E,[_|T],N):-counter(E,T,N).
```

Условием остановы является тот факт, что если список пустой, то элементов 0. Если голова списка - нужный элемент, то их всего столько же сколько в хвосте плюс 1. Иначе этих элементов столько же, сколько и в хвосте.



Реализация с использованием стандартных предикатов:
```prolog
counter2(E,L,N):-remove(E,L,R), counter2(E,R,N1), N is N1+1,!.  
counter2(_,_,0).
```
Заданный элемент удаляется предикатом remove пока это возможно. В переменную N записывается сколько раз получилось удалить заданный элемент. Условием остановы является тот факт, что мы больше не можем удалить заданный элемент из списка, а следовательно число его вхождений на этом этапе равно 0.

## Задание 1.2: Предикат обработки числового списка

`max(Elem, List) ` - предикат реализует поиск максимально элемента Elem в списке List.

Примеры использования:
```prolog
| ?- max(X,[1,5,4,5,0,2]).
X = 5

| ?- max(X,[1,5,4,5,0,8]).
X = 8 

| ?- max(X,[10,9,8,7,6]).
X = 10

```

Реализация без использования стандартных предикатов:
```prolog
max(H,[H]).                            
max(H,[H|T]):-max(E,T),H>E,!.
max(E,[_|T]):-max(E,T).
```

Если список состоит из одного элемента, то этот элемент и есть максимальный. Голова списка является максимальным элементом, если она больше найденого на предыдущем этапе максимального элемента, иначе продолжаем поиск максимального элемента.



Реализация с использованием стандартных предикатов:
```prolog
max2(E,L):- length(L,1), append(_,[E],L).
max2(H,[H|T]):-max(E,T),H>E,!.
max2(E,[_|T]):-max(E,T).
```
Данный предикат практически аналогичен предикату max за исключением условия остановы, в котором присутствуют стандартные предикаты. 
Когда длина списка равна 1, тогда максимальный элемент, это последний элемент данного списка. 

## Задание 1.3: Пример совместного использования предикатов
В качестве примера совместного использования предикатов был реализован предикат example :
`example(Number,ListMain,Elem,List2)` - предикат выводит наибольшее кол-во(Number) повторяющихся элементов в списке(ListMain) с помощью реализованных раннее предикатов counter и max. Переменные Elem и List2 являются вспомогательными.

Примеры использования:
```prolog
| ?- example(X,['a','b','c','c','a','c'],_,_).
X = 3

| ?- example(X,['a','b','b','c','a','c'],_,_).
X = 2

```
Наибольшее число раз в список входит символ 'c'. Предикат example вывел X=3 - максимальное кол-во вхождений данного символа в список.


Реализация:
```prolog
example(_,[A],A,[1]).
example(X,[H,A|T],H,L2):-example(_,[A|T],A,L1),counter(H,[H,A|T],N),append(L1,[N],L2),max(X,L2),!. 

```
Вначале с помощью предиката counter подсчитывается кол-во вхождений элемента Elem на отрезках списка ListMain, результат записывается в List2, на каждом этапе с помощью предиката max происходит поиск максимального кол-ва вхождений повторяющихся элементов.


## Задание 2: Реляционное представление данных

Реляционное представление показывает отношения между объектами, а задачей программиста является анализ этих отношений. Результат запроса к такому виду данных -- это множество ответов, удовлетворяющих внутренней структуре программы. Вся задача сводится к реализации такой структуры, которая обеспечит выдачу ответов. В ходе отладки своей программы я сталкивалась с ситуацией, когда ответ охватывал не все необходимые объекты. К преимуществам можно отнести относительную простоту разработки: программа разбивается на отдельные компоненты, c которыми просто и легко работать благодаря встроенным в Prolog предикатам. К минусам такого представления относится невсегда удобная работа с такими данными .
В моем представлении факты записывались так: grade(Group,Subject,Student,Mark).
C помощью встроенного предиката findall или setof можно было легко найти список студентов определённой группы или список студентов, которые не сдали какой-либо предмет.

Вариант 2
  - Напечатать средний балл для каждого предмета
  - Для каждой группы, найти количество не сдавших студентов 
  - Найти количество не сдавших студентов для каждого из предметов

Вариант реляционного представления : two.pl


1. `average_score(Subject,Average_score)` - предикат выводит средний балл для каждого предмета.

Пример использования:
```prolog
| ?- average_score(Subject,Average_score).

Average_score = 3.9285714285714284
Subject = 'Информатика' ? ;

Average_score = 3.9642857142857144
Subject = 'Логическое программирование' ? ;

Average_score = 3.8928571428571428
Subject = 'Математический анализ' ? ;

Average_score = 3.9285714285714284
Subject = 'Психология' ? ;

Average_score = 3.9642857142857144
Subject = 'Функциональное программирование' ? ;

Average_score = 3.75
Subject = 'Английский язык' ? ;


| ?- average_score('Информатика',Average_score).
Average_score = 3.9285714285714284
```

Реализация :
```prolog
sum([X],X).
sum([X|T],S):-sum(T,S1),S is S1+X.

get_mark(Subject,Mark):- findall(Mrk,grade(_,_,Subject,Mrk),Marks),sum(Marks,S), length(Marks,Len), Mark is S/Len.

mark([H],H,X):-get_mark(H,X),!.
mark([_|T],A,X):- append(_,[H,A|_],[H|T]),mark(T,A,X).
mark(Subj,H,X):- append([H],_,Subj), get_mark(H,X).

average_score(Subject,X):- setof(Y,W^A^X^grade(W,X,Y,A),Subj), mark(Subj,Subject,X).
```
Основная идея в том, что с помощью setof происходит запись всех имеющихся учебных предметов в список Subj.  С помощью предиката findall мы записываем в список Marks все оценки для заданного предмета, с помощью sum находим их сумму и высчитываем средний балл. При помощи предика mark для каждого предмета из списка Subj выводим его средний балл.

2. `group_dont_pass(Group,Number)` - предикат выводит для каждой группы количество не сдавших студентов.

Пример использования:
```prolog
| ?- group_dont_pass(Group,Number).

Group = 102
Number = 5 ? ;

Group = 103
Number = 4 ? ;

Group = 104
Number = 2 ? ;

Group = 101
Number = 2


| ?- group_dont_pass(104,Number).
Number = 2 

```

Реализация :
```prolog
get_dont_pass(Group,Number):- findall(Name,grade(Group,Name,_,2),List),length(List,Number).

dont_pass([H],H,N):-get_dont_pass(H,N),!.
dont_pass([_|T],A,X):- append(_,[H,A|_],[H|T]),dont_pass(T,A,X).
dont_pass(Groups,H,X):- append([H],_,Groups), get_dont_pass(H,X).

group_dont_pass(Group,Number):-setof(Grp,W^A^X^grade(Grp,X,W,A),Groups), dont_pass(Groups,Group,Number).
```

С помощью setof происходит запись всех имеющихся учебных групп в список Groups. Предикат findall записывает в список List фамилии всех несдавших студентов в заданной группе. Высчитав длину этого списка можно узнать сколько всего несдавших. При помощи предика dont_pass для каждой группы из списка Groups выводим количество несдавших студентов.

3. `subjects_dont_pass(Subject,Number)` - предикат выводит количество не сдавших студентов для каждого из предметов.

Пример использования:
```prolog
| ?- subjects_dont_pass(Subject,Number).

Number = 2
Subject = 'Информатика' ? ;

Number = 2
Subject = 'Логическое программирование' ? ;

Number = 3
Subject = 'Математический анализ' ? ;

Number = 1
Subject = 'Психология' ? ;

Number = 1
Subject = 'Функциональное программирование' ? ;

Number = 4
Subject = 'Английский язык'


| ?- subjects_dont_pass('Психология',Number).
Number = 1 

```

Реализация :
```prolog
get_dont_pass2(Subject,Number):- findall(Name,grade(_,Name,Subject,2),List),length(List,Number).

dont_pass_exams([H],H,N):-get_dont_pass2(H,N),!.
dont_pass_exams([_|T],A,X):- append(_,[H,A|_],[H|T]),dont_pass_exams(T,A,X).
dont_pass_exams(Groups,H,X):- append([H],_,Groups), get_dont_pass2(H,X).

subjects_dont_pass(Subject,Number):- setof(Sbjct,W^A^X^grade(W,X,Sbjct,A),Subjects), dont_pass_exams(Subjects,Subject,Number).
```
С помощью setof происходит запись всех имеющихся учебных предметов в список Subjects. Предикат findall записывает в список List фамилии всех несдавших заданный предмет студентов. Высчитав длину этого списка можно узнать сколько всего несдавших. При помощи предика dont_pass_exams для каждого предмета из списка Subjects выводим количество несдавших студентов.

## Выводы
Данная лабораторная работа была для меня первой возможностью написания полезных программ на языке Prolog. По мере работы с ней я познакомилась со списками и некоторыми встроенными предикатами для работы с ними. Основное отличие Пролога от привычных мне императивных языков программирования в том, что программист описывает задачу, которую Пролог,на самом деле, решает сам. Тексты программ на Прологе просты в чтении и понимании, так как представляют собой набор фактов и правил, но в тоже время их написание сложный процесс, который заставляет программиста мыслить логически, глобально и не пошагово. Можно сказать, что логическое программирование помогает найти нетривиальное решение какой-то обыденной задачи. В понимании как написать свои предикаты, мне помогла трассировка. Когда наблюдаешь пошаговое выполнение предиката, наглядно видно, в каком порядке и как выполняются правила, для меня это не всегда было очевидно. Благодаря данной лабораторной работе я лучше поняла концепцию логических языков программирования.

