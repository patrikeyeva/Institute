# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Патрикеева Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   14.11      |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*: оценка сложности?


## Введение

В языке Prolog есть возможность рассматривать большое количество решений какой-либо задачи и далее из этих решений выбирать подходящие. Поиск решений задачи состоит, по сути, в обходе дерева возможных решений и выделения тех ветвей, которые удовлетворяют условию задачи. Существуют различные стратегии обхода этих деревьев, одним из таких является  метод порождения и проверок.  Суть этого метода в том, что вначале генерируется множество неполных (но возможно и полных) решений, которые затем проверяются на соответствие условию задачи.  Если было выявлено несоответствие, то  ветвь поиска отсекается (т.е. данное возможное неполное решение не рассматривается).  Далее происходит возврат и рассмотрение следующего возможного решения. В случае же успеха  это решение может использоваться в дальнейшем. Для генерации и проверки обычно создаются отдельные специальные предикаты, которые и выполняют эти функции. Другим подходом к решению логических задач является метод ветвей и границ. При этом подходе большая часть возможных решений отсекается на ранней стадии либо вообще не генерируется и не рассматривается, в отличие от метода ветвей и границ, где рассматриваются все решения. Получается, что программа, использующая для поиска решения второй метод, будет работать быстрее.

Prolog является логическим языком программирования  и удобен в поиске решений логических задач. Для решения одним из перечисленных выше методов,  в Prolog предусмотрены списки и предикаты для их обработки, а так же отсечение и бектрекинг.  Факты из условия  могут быть легко записаны в виде утверждений логики предикатов. 

## Задание

В семье Семеновых пять человек: муж, жена, их сын, сестра мужа и отец жены. Все они работают. Один инженер, другой юрист, третий слесарь, четвертый экономист, пятый учитель. Вот что еще известно о них. Юрист и учитель не кровные родственники. Слесарь хороший спортсмен. Он пошел по стопам экономиста и играет в футбол за сборную завода. Инженер старше жены своего брата, но моложе, чем учитель. Экономист старше, чем слесарь. Назовите профессии каждого члена семьи Семеновых.

## Принцип решения

Данная задача является задачей на поиск соответствий. Каждому члену семьи нам надо сопоставить соответствующую профессию. Для решения данной задачи был написан определенный набор утверждений.  С помощью предиката `family(person)` записываем членов семьи Семёновых, предикат `male(person_is_man)` обозначает мужчин в данной семье. Так же для решения задачи необходим будет предикат `hasbrother(person)` для обозначения людей, у которых есть брат. В конкретно нашей задаче такой человек будет только один. С помощью предиката `younger(younger_person, older_person)` записываем информацию о том, кто кого младше. Строчка кода `younger(X,X):- true` понадобится в дальнейшем, для получения правильного результата поиска решений предиката not от предиката younger.

Так же для решения данной задачи необходимо было определить не кровных родственников. Они были записаны с помощью предиката `not_blood_relative(person1,person2)`. Для того, чтобы сократить код программы был написан следующий предикат :

```prolog
not_blood_relatives(X, Y):- not_blood_relative(X, Y);not_blood_relative(Y, X).
```
Данная строка кода позволяет не дублировать предикат `not_blood_relative(person1,person2)` переставляя местами person1 и person2.

Чтобы получить решение, надо найти пятерых таких членов семьи с разными именами(в качестве имени выступает название члена семьи), имеющие разные профессии. Каждый человек в семье описывается предикатом `person(name, vocation)`.

```prolog
solve_list(Solve):-
Solve = [ person(Slesar_name, slesar), person(Economist_name,economist), person(Teacher_name,teacher), person(Lawyer_name,lawyer), person(Engineer_name,engineer)],
family(Slesar_name), family(Economist_name), family(Teacher_name), family(Lawyer_name), family(Engineer_name), unique([Slesar_name, Economist_name, Teacher_name, Lawyer_name,Engineer_name])
```
Вспомогательный предикат `unique([List])` следит за тем, чтобы элементы в списке все были разными и не повторялись, поскольку один и тот же человек не может иметь разные профессии. Код данного предиката выглядит следующим образом : 

```prolog
unique([]):-!.
unique([Head|Tail]):-member(Head, Tail), !, fail;unique(Tail).
```
Такое правило `solve_list` сгенирит всевозможные решения данной задачи без учёта ограничений. 

Ограничения можно записать следующим образом: 
1. Юрист и учитель не кровные родственники.

```prolog
not_blood_relatives(Lawyer_name, Teacher_name)
```
2.  Слесарь хороший спортсмен. Он пошел по стопам экономиста и играет в футбол за сборную завода.
Из данного предложения делаем вывод, что слесарь и экономист - мужчины.

```prolog
male(Slesar_name), male(Economist_name)
```
3. Инженер старше жены своего брата, но моложе, чем учитель.
Из данного предложения делаем вывод, что у инженера есть брат, а так же, что жена моложе учителя и соответственно не может быть ни учителем, ни инженером.

```prolog
hasbrother(Engineer_name),
not(younger(Engineer_name, wife)),
not(younger(Teacher_name, Engineer_name)),
not(younger(Teacher_name, wife)).
```
Предикат not помогает нам найти такие решения, которые не противоречат условию задачи. При использовании предиката younger без not мы можем упустить возможные решения, поскольку в результате один из проверяемых может быть младше другого, но на начальном этапе задачи про это неизвестно, т.е. нужного факта может не быть среди известных фактов. При описании данных ограничений нам и потребовалась строчка кода `younger(X,X):- true` про которую уже упоминалось выше. Данная строчка кода поможет избежать таких противоречий как истинность факта "жена моложе жены" и так далее. Например, при выполнении строчки кода `not(younger(Teacher_name, wife))` ограничение о том, что жена не может быть учителем, будет соблюдено.

4. Экономист старше, чем слесарь.

```prolog
not(younger(Economist_name, Slesar_name))
```
Для того, чтобы вывод выглядел симпатичнее был разработан предикат `solve(A, B, C, D, E)`. Данный предикат с помощью встроенного предиката `member` извлекает данные из полученного списка Solve, который был получен в результате выполнения предиката solve_list. Данные в списке хранятся в виде набора фактов с помощью предиката `person(name, vocation)`.

```prolog
solve(A,B,C,D,E):- member(person(A, slesar), Solve), member(person(B, economist), Solve), member(person(C, teacher), Solve),
                   member(person(D, lawyer), Solve), member(person(E, engineer), Solve), solve_list(Solve),!.
```

Результат работы программы :

```prolog
| ?- solve(Slesar, Economist, Teacher, Lawyer, Engineer).

Economist = wifes_father
Engineer = husband_sister
Lawyer = wife
Slesar = son
Teacher = husband
```

## Выводы

Prolog очень удобен для решения логических задач. C помощью фактов и правил мы описываем задачу, решение которой ищет уже сам Prolog. Код решения выглядит очень понятно и аккуратно. 

Данная лабораторная работа помогла мне еще лучше разобраться в концепции самого языка Prolog и в особенностях написания на нём программ, на практике убедиться в удобстве решения логических задач на этом языке, а так же лучше понять подходы для решения логических задач.
Эта лабораторная работа заставила меня задуматься над тем, как можно было бы решить эту задачу, например, на языке С++. Решение, к сожалению, реализовать не удалось. Скорее всего код этой задачи на одном из языков программирования высокого уровня выглядел бы намного больше, а возможно решение этой задачи вовсе нельзя написать на одном из таких языков. В любом случае удобнее и эффективнее всего для решения таких задач использовать именно Prolog. На этом языке я смогла получить единственное верное решение задачи, которое не противоречит условию. Выполнение программы занимает 16 миллисекунд.
Наверное, конкретно эту задачу было бы быстрее решить человеку самому в уме или на листочке. Лично у меня написание программы, несмотря на её несложность, заняло больше времени, чем решение вручную. 
