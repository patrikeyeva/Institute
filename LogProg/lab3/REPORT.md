# № Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студентка: Патрикеева Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   1.12.2019  |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В современном мире все популярнее становится исскуственный интеллект, который в свою очередь постоянно сталкивается с задачей нахождения решения, имея заданное пространство состояний. Именно для таких задач необходимы алгоритмы поиска в пространствах состояний. Для решения задач, представление которых можно описать набором некоторых состояний объектов, можно применять различные алгоритмы поиска в графах. Так, граф можно легко получить, если определить состояния, как его вершины, а дуги, как переходы из одного состояния в другое. Так как любой алгоритм поиска представляет из себя нахождение пути из одной вершины в другую, то в рамках задачи этот путь является ответом на то, какими переходами из одних состояний в другие можно достичь конечного состояния. Таким способом можно легко решать задачи на перемещения объектов из одного места в другое. Благодаря тому, что поиск решения на Prolog'е основан на обходе дерева, подобные задачи легко решаются использованием алгоритмов поиска. Если при поиске была достигнута вершина(состояние), из которого дальше пути нет, то необходимо откатиться до какого-то предыдущего состояния, которое определяется алгоритмом. Такой процесс backtracing'а заложен "внутри" Prolog'а, поэтому нет необходимости писать в программе дополнительный код. Именно поэтому Prolog является отличным средством для решения подобных задач.

## Задание

2. Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное количество шагов, если в их распоряжении 3-ех местная лодка и ни при каких обстоятельствах миссионеры не должны остаться в меньшинстве.

## Принцип решения

Принцип работы заключается в составлении алгоритмов поиска решений в пространстве состояний. Есть два случая нахождения лодки, она либо у левого берега, либо у правого. Взависимости от её местоположения мы переправляем на ней людей либо в левую сторону, либо в правую. Эти действия каждый раз чередуются, т.к. лодка сама по себе не может приплыть на другой берег. Соблюдая все правила, мы совершаем данные действия, пока левый берег не станет пустой и все люди не переправятся на правый. Нужно найти комбинацию таких действий, приводящих нас к описанному выше результату. Для этого я использовала 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением.  
Для осуществления переходов в графе состояний был создан предикат `move`. Он определяет количество человек на каждом из берегов после перехода лодки. Третий аргумент этого предиката определяет местоположение лодки в данный момент : 1 - она находится на левом берегу, 2 - она находится на правом берегу. Ниже приведён пример данного предиката, когда лодка находится у левого берега. Предикат для правого берега практически аналогичен.

```prolog
move(Left, New_left, 1) :-
  boat(Between),
  subtraction(Left, Between, New_left),
  counter(New_left, "К", N1),
  counter(New_left, "М", N2),
  check_safe(N2, N1),
  subtraction(["К", "К", "К", "М", "М", "М"], New_left, New_right),
  counter(New_right, "К", N3),
  counter(New_right, "М", N4),
  check_safe(N4, N3).
```
Предикат `boat` генерит всевозможные расположения людей в лодке в виде списка. Таких расположений всего 8, с учетом введённых ограничений.
Предикат `subtraction` как бы вычитает один список из другого и получает третий, в результате мы получаем элементы, которые есть в одном списке, но которых нет в другом. Это нужно, чтобы узнать, кто находится на берегу, после того, как лодка с людьми перешла на другой берег. 
Предикат `counter` считает сколько раз данный элемент встретился в списке. Его мы используем для подсчета количества каннибалов и миссионеров, которые находятся на одном береге.
Предикат `check_safe` осуществляет проверку на то, что каннибалов не больше, чем миссионеров, которые находятся с ними на одном береге, т.е. осуществляет безопасность миссионеров.  


Так же я использовала предикат `prolong` для продления путей в графе и предотвращения зацикливания. 

```prolog
prolong([p(X, 1)|T], [p(Y, 2), p(X, 1)|T]):-
  move(X, Y, 1),
  not(list_member(p(Y, 2), [p(X, 1)|T])).

prolong([p(X, 2)|T], [p(Y, 1), p(X, 2)|T]):-
  move(X, Y, 2),
  not(list_member(p(Y, 1), [p(X, 2)|T])).
```
Ниже представлены 3 алгоритма, которыми я пользовалась для нахождений кратчайших путей.

```prolog
% поиск в глубину
dfs_path([p(X, 2)|T], X, [p(X, 2)|T]).
dfs_path([p(R, N)|P], X, L):- prolong([p(R, N)|P], P1), dfs_path(P1, X, L).

dfs_search(Before, After):-
 get_time(Time1),
 % N is 20,                              
 dfs_path([p(Before, 1)], After, L),
 get_time(Time2),
 % length(L, N2), N <= N2, 
 T is Time2-Time1,
 write('Time is '),
 write(T), writeln(' sec')
 output(L,1),
 % N is N2.

% поиск в ширину
bfs_path([[p(X, 2)|T]|_], X, [p(X, 2)|T]).

bfs_path([B|P], X, L):-
  findall(W, prolong(B, W), Q),
  append(P, Q, QP),
  !, bfs_path(QP, X, L);
  bfs_path(P, X, L).

 bfs_search(Before, After):-
  get_time(Time1), 
  % N is 20,
  bfs_path([[p(Before, 1)]], After, L),
  get_time(Time2),
  T is Time2 - Time1,
  % length(L, N2), N <= N2,
  write('Time is '),
  write(T), 
  writeln(' sec'),
  output(L,1).

% поиск с итерационным углублением

natural(1).
natural(B) :- natural(A), B is A + 1.

itdpth([p(A, 2)|T], A, [p(A, 2)|T], 0).

itdpth(P, A, L, N) :-
  N > 0,
  prolong(P, Pl),
  Nl is N - 1,
  itdpth(Pl, A, L, Nl).

id_search(Before, After) :-
  get_time(Time1),
  natural(N),
  itdpth([p(Before, 1)], After, L, N),
  get_time(Time2),
  T is Time2 - Time1,
  write('Time is '),
  write(T),
  writeln(' sec'),
  output(L,1), !.
 ```
Эти алгоритмы немного отличаются от стандартных. Во-первых в код добавлен предикат `get_time` для того, чтобы засечь время работы алгоритма. Некоторые части кода закомечены, но я использовала их для того, чтобы мне не выводились всевозможные решения, а выводились самые короткие. В качестве N я устанавливаю ограничение на возможное количество действий в процессе поиска пути. После того, как я получила путь в результате выполнения алгоритма поиска, я нахожу его длину и вывожу его только в том случае, если его длина меньше длины предыдущего найденного пути.  

Для представления пути в более удобном для чтения виде я реализовала предикат `output`. Поэтому в выводе указано на каком береге сколько человек было после выполнения какого-либо действия. И так же выводится стрелочка, которая показывает, на какой берег были переправлены люди по результату выполненного действия.

```prolog
output([p(X, 1)],_):- write("Left bank:"), write(X), subtraction(["К", "К", "К", "М", "М", "М"], X, Y), write(' --- '), write("Right bank:"), writeln(Y).
output([p(X, _)|T],1):- output(T,2), write("Left bank:"), write(X), subtraction(["К", "К", "К", "М", "М", "М"], X, Y), write('-->'), write("Right bank:"), writeln(Y).
output([p(X, _)|T],2):- output(T,1), write("Left bank:"), write(X), subtraction(["К", "К", "К", "М", "М", "М"], X, Y), write('<--'), write("Right bank:"), writeln(Y).
```
## Результаты

Ниже представлены результаты работы программы. Здесь я выводила только самый первый найденный путь. Первой строкой всегда выводится время, которое было затрачено на поиск выполняемым алгоритмом.

```prolog
?- bfs_search(["К", "К", "К", "М", "М", "М"], []).
Time is 0.015583992004394531 sec
Left bank:[К,К,К,М,М,М] --- Right bank:[]
Left bank:[М,М,М]-->Right bank:[К,К,К]
Left bank:[К,М,М,М]<--Right bank:[К,К]
Left bank:[К]-->Right bank:[К,К,М,М,М]
Left bank:[К,К]<--Right bank:[К,М,М,М]
Left bank:[]-->Right bank:[К,К,К,М,М,М]
true 

?- dfs_search(["К", "К", "К", "М", "М", "М"],[]).
Time is 0.019949523162841797 sec
Left bank:[К,К,К,М,М,М] --- Right bank:[]
Left bank:[М,М,М]-->Right bank:[К,К,К]
Left bank:[К,М,М,М]<--Right bank:[К,К]
Left bank:[К]-->Right bank:[К,К,М,М,М]
Left bank:[К,М,М,К]<--Right bank:[К,М]
Left bank:[М,К]-->Right bank:[К,К,М,М]
Left bank:[К,М,М,М,К]<--Right bank:[К]
Left bank:[К,К]-->Right bank:[К,М,М,М]
Left bank:[К,К,К]<--Right bank:[М,М,М]
Left bank:[]-->Right bank:[К,К,К,М,М,М]
true 

?-  id_search(["К", "К", "К", "М", "М", "М"],[]).
Time is 0.01558542251586914 sec
Left bank:[К,К,К,М,М,М] --- Right bank:[]
Left bank:[М,М,М]-->Right bank:[К,К,К]
Left bank:[К,М,М,М]<--Right bank:[К,К]
Left bank:[К]-->Right bank:[К,К,М,М,М]
Left bank:[К,К]<--Right bank:[К,М,М,М]
Left bank:[]-->Right bank:[К,К,К,М,М,М]
true
```
Получается, что самый кратчайший путь для решения задачи равен 5. 

| Алгоритм поиска |          Время работы          |  Длина найденного пути  |
|-----------------|--------------------------------|-------------------------|
| В глубину       |      0.019949523162841797      |           9             |
| В ширину        |      0.015583992004394531      |           5             |
| ID              |      0.01558542251586914       |           5             |                              |                |

## Выводы

Эта лабораторная работа научила меня решать задачи исскуственного интеллекта с помощью алгоритмов нахождения путей в пространстве состояний на Прологе. Пролог оказался очень удобным для таких задач и как оказалось, он действительно часто использовался именно для подобных целей. Так же Пролог в очередной раз показал и доказал своё преимущество перед языками программирования высокого уровня. Мне приходилось писать алгоритм поиска в глубину и в ширину на языке программирования С++. Код был больше и занял много времени. 

Для решения данной задачи нет разницы, какой из алгоритмов поиска использовать. Однако самым интересным по реализации мне показался алгоритм с итерационным погружением, который позволяет искать наикратчайший путь с относительно небольшим расходом памяти. Такой алгоритм следует использовать когда стоит задача нахождения наименьшего пути в условиях ограниченной памяти.
Алгоритм поиска в ширину тоже довольно удобный. И как показало замерение времени, он работает чуть быстрее для моей задачи, чем алгоритм с итерационным погружением. Так же он выводит найденные пути в порядке возрастания, т.е. первый найденный им путь будет самым коротким. Конкретно для моей задачи это очень удобно. Алгоритм поиска в глубину был самым простым в реализации, других преимуществ перед описанными выше алгоритмами я не нашла. Подобные алгоритмы я могу использовать и дальше, в том числе и в моей курсовой работе, где вершинами графа являются мои родственники из родословного дерева, а связями их родственные отношения. 







